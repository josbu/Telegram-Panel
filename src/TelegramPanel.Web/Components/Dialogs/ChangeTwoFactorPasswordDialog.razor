@namespace TelegramPanel.Web.Components.Dialogs
@inject AccountManagementService AccountManagement
@inject TelegramPanel.Core.Services.Telegram.AccountTelegramToolsService AccountTelegramTools
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@using TelegramPanel.Data.Entities

<MudDialog>
    <DialogContent>
        <MudStack Spacing="2">
            @if (IsBatchMode)
            {
                <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Dense="true">
                    将对选中的账号批量修改 Telegram 两步验证（二级密码）。
                    @if (!useStoredPasswords)
                    {
                        <span>请确认你输入的"原二级密码"在这些账号上是一致的，否则对应账号会失败。</span>
                    }
                </MudAlert>
            }

            <MudText Typo="Typo.subtitle2">账号数量：@accounts.Count</MudText>

            @if (IsBatchMode)
            {
                <MudSwitch @bind-Value="useStoredPasswords" Label="使用数据库中保存的原二级密码" Color="Color.Primary" />

                @if (useStoredPasswords)
                {
                    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true">
                        将为每个账号使用其在数据库中保存的二级密码作为原密码。若某账号未保存密码，则以空密码尝试。
                    </MudAlert>
                }
                else
                {
                    <MudTextField @bind-Value="currentPassword" Label="原二级密码（统一）" Variant="Variant.Outlined" InputType="InputType.Password"
                                  HelperText="如果账号未开启两步验证，可留空" />
                }
            }
            else
            {
                <MudTextField @bind-Value="currentPassword" Label="原二级密码" Variant="Variant.Outlined" InputType="InputType.Password"
                              HelperText="@SingleAccountPasswordHelperText" />
            }

            <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true">
                忘记原二级密码时，可发起"重置二级密码"申请（通常需要等待 7 天）。等待结束后，再回来设置新的二级密码即可。
            </MudAlert>

            <MudTextField @bind-Value="newPassword" Label="新二级密码" Variant="Variant.Outlined" InputType="InputType.Password"
                          Required="true" />

            <MudTextField @bind-Value="confirmPassword" Label="确认新二级密码" Variant="Variant.Outlined" InputType="InputType.Password"
                          Required="true" />

            <MudTextField @bind-Value="hint" Label="密码提示（可选）" Variant="Variant.Outlined"
                          HelperText="Telegram 会展示给你作为提示，建议不要写明文密码" />

            <MudCheckBox @bind-Value="saveNewPasswordToDb" Label="修改成功后将新密码保存到数据库" Color="Color.Primary" />

            @if (running || results.Count > 0)
            {
                <MudDivider Class="my-2" />

                <MudStack direction="Row" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Typo="Typo.body2">进度：@processed / @accounts.Count</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Success">成功：@success</MudText>
                    <MudText Typo="Typo.body2" Color="Color.Error">失败：@failed</MudText>
                    @if (running)
                    {
                        <MudProgressCircular Indeterminate="true" Size="Size.Small" />
                    }
                </MudStack>

                <MudTable Items="@results" Dense="true" Hover="true" Breakpoint="Breakpoint.Sm">
                    <HeaderContent>
                        <MudTh>账号</MudTh>
                        <MudTh>结果</MudTh>
                        <MudTh>原因/提示</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="账号">@context.Phone</MudTd>
                        <MudTd DataLabel="结果">
                            <MudChip T="string" Size="Size.Small" Color="@(context.Success ? Color.Success : Color.Error)">
                                @(context.Success ? "成功" : "失败")
                            </MudChip>
                        </MudTd>
                        <MudTd DataLabel="原因/提示">@((context.Message ?? "").Trim())</MudTd>
                    </RowTemplate>
                </MudTable>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Text" Color="Color.Default" OnClick="Cancel" Disabled="@running">关闭</MudButton>
        <MudButton Variant="Variant.Outlined" Color="Color.Warning" OnClick="StartReset" Disabled="@running">
            忘记密码（申请重置）
        </MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Start" Disabled="@running">
            @if (running)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                <span>执行中...</span>
            }
            else
            {
                <span>开始修改</span>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

@code
{
    [CascadingParameter] private MudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public IReadOnlyList<int> AccountIds { get; set; } = Array.Empty<int>();

    private List<Account> accounts = new();

    private string currentPassword = "";
    private string newPassword = "";
    private string confirmPassword = "";
    private string hint = "";
    private bool useStoredPasswords;
    private bool saveNewPasswordToDb = true;

    private bool running;
    private int processed;
    private int success;
    private int failed;

    private readonly List<ResultRow> results = new();

    private bool IsBatchMode => accounts.Count > 1;

    private string SingleAccountPasswordHelperText
    {
        get
        {
            if (accounts.Count != 1)
                return "如果账号未开启两步验证，可留空";

            var stored = accounts[0].TwoFactorPassword;
            if (string.IsNullOrEmpty(stored))
                return "如果账号未开启两步验证，可留空（数据库中未保存密码）";

            return "已自动填充数据库中保存的密码";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var ids = AccountIds?.Distinct().Where(x => x > 0).ToList() ?? new List<int>();
        if (ids.Count == 0)
            return;

        var all = await AccountManagement.GetAllAccountsAsync();
        accounts = all.Where(a => ids.Contains(a.Id)).OrderBy(a => a.Id).ToList();

        // 单个账号时，自动填充数据库中保存的原二级密码
        if (accounts.Count == 1 && !string.IsNullOrEmpty(accounts[0].TwoFactorPassword))
        {
            currentPassword = accounts[0].TwoFactorPassword;
        }
    }

    private async Task Start()
    {
        if (running)
            return;

        if (accounts.Count == 0)
        {
            Snackbar.Add("未选择账号", Severity.Warning);
            return;
        }

        if (string.IsNullOrWhiteSpace(newPassword))
        {
            Snackbar.Add("新二级密码不能为空", Severity.Warning);
            return;
        }

        if (!string.Equals(newPassword, confirmPassword, StringComparison.Ordinal))
        {
            Snackbar.Add("两次输入的新二级密码不一致", Severity.Warning);
            return;
        }

        bool? confirm = await DialogService.ShowMessageBox(
            "确认修改",
            $"将对 {accounts.Count} 个账号修改二级密码。是否继续？",
            yesText: "继续", cancelText: "取消");

        if (confirm != true)
            return;

        running = true;
        processed = 0;
        success = 0;
        failed = 0;
        results.Clear();

        try
        {
            foreach (var a in accounts)
            {
                // 确定使用的原密码：批量模式下可选择使用数据库中保存的密码
                var effectiveCurrentPassword = (IsBatchMode && useStoredPasswords)
                    ? (a.TwoFactorPassword ?? "")
                    : currentPassword;

                var (ok, err) = await AccountTelegramTools.ChangeTwoFactorPasswordAsync(
                    accountId: a.Id,
                    currentPassword: effectiveCurrentPassword,
                    newPassword: newPassword,
                    hint: hint,
                    cancellationToken: CancellationToken.None);

                processed++;
                if (ok)
                {
                    success++;

                    // 修改成功后，将新密码保存到数据库
                    if (saveNewPasswordToDb)
                    {
                        try
                        {
                            a.TwoFactorPassword = newPassword;
                            await AccountManagement.UpdateAccountAsync(a);
                        }
                        catch
                        {
                            // 保存失败不影响主流程
                        }
                    }
                }
                else
                {
                    failed++;
                }

                results.Add(new ResultRow(a.DisplayPhone, ok, ok ? null : err));
                StateHasChanged();
            }

            Snackbar.Add($"二级密码修改完成：成功 {success}/{accounts.Count}，失败 {failed}/{accounts.Count}", failed == 0 ? Severity.Success : Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"执行失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            running = false;
        }
    }

    private async Task StartReset()
    {
        if (running)
            return;

        if (accounts.Count == 0)
        {
            Snackbar.Add("未选择账号", Severity.Warning);
            return;
        }

        bool? confirm = await DialogService.ShowMessageBox(
            "确认申请重置",
            $"将对 {accounts.Count} 个账号向 Telegram 发起【重置二级密码】申请（通常需要等待 7 天）。是否继续？",
            yesText: "继续", cancelText: "取消");

        if (confirm != true)
            return;

        running = true;
        processed = 0;
        success = 0;
        failed = 0;
        results.Clear();

        try
        {
            foreach (var a in accounts)
            {
                var (ok, msg, _) = await AccountTelegramTools.RequestTwoFactorPasswordResetAsync(
                    accountId: a.Id,
                    cancellationToken: CancellationToken.None);

                processed++;
                if (ok) success++; else failed++;
                results.Add(new ResultRow(a.DisplayPhone, ok, msg));
                StateHasChanged();
            }

            Snackbar.Add($"重置申请已处理：成功 {success}/{accounts.Count}，失败 {failed}/{accounts.Count}", failed == 0 ? Severity.Success : Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"执行失败：{ex.Message}", Severity.Error);
        }
        finally
        {
            running = false;
        }
    }

    private void Cancel() => MudDialog.Close();

    private sealed record ResultRow(string Phone, bool Success, string? Message);
}
